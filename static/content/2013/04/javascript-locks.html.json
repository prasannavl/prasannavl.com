{"name":"Javascript locks","date":"2013-04-27T00:00:00.000Z","url":"2013/04/javascript-locks.html","tags":[],"content":"> <span style=\"color: #e06666;\">**Note:** This was written when the javascript ecosystem was in a whole different era. This article is here only for historical reasons. **Do not ever do this**, unless you know what you're doing. Also note that this is more of a task library than just for locking - this was a way to solve a particular problem I was facing. That being said, this is almost always a wrong approach for any problem in today's world. :)</span>\r\n\r\nThings break. Codes break. Javascript - they don't just break, they break everything along with it. Being the simplest language has its downsides. But one of the common reasons that happen is people tend to forget that everything in JS is asynchronous.\r\n\r\nYou probably would get away with it, if you're writing simple applications. But when complexity increases, it almost becomes impossible to solve certain problems with the async design pattern, not without a locking mechanism. Especially, in a javascript environment due to its full async nature making timing absolutely unreliable and unpredictable. While locking is common in a multi-thread environment, Js in most common environments will run on a single-thread and due to only simple tasks being performed with it, the old days never saw a need for locking. But for today's complex applications, you just need performant and reliable locking. There's no way around it.\r\n\r\nAnd that's exactly what the below tiny (< 2kb) library provides.\r\n\r\n**GitHub: [https://github.com/prasannavl/JsLocks](https://github.com/prasannavl/JsLocks)**\r\n\r\n**Download: [JsLocks.min.js](https://raw.github.com/prasannavl/JsLocks/master/JsLocks.min.js)**\r\n\r\n**API:**\r\n\r\n```\r\nLocker.Lock(lockName, callbackFunction, [priority=0]);\r\nLocker.LockManual(lockName, callbackFunction, [priority=0]);\r\nLocker.Release(lockName);\r\n\r\nLocker.DiscardQueue(lockName);\r\n\r\nLocker.LockManualIfInstant(lockName, callbackFunction, [priority=0]);\r\nLocker.LockIfInstant(lockName, callbackFunction, [priority=0]);\r\n\r\n```\r\n\r\n**Basic usage:**\r\n\r\n```\r\nfunction getALife() {\r\n        Locker.Lock(\"thebiglock\", function() {\r\n        DoSomeWork();\r\n        FetchNewAjaxContentAndReplaceMyMainContent();\r\n    });\r\n};\r\n```\r\n\r\nYou could see how the above just cannot work without locking. Without this locking, executing getALife even twice in a row, basically ruins your life. Since you have no idea when you'll get the ajax request back. You have no way of knowing if they will work in order. Instead, your requests will get mangled up, and you have no way to load items in parallel without messing up the order. While this is a simple example, its uses go much further.\r\n\r\nThe above is a auto-release lock. If you want manual control over the locks, just use the ManualLock and Release functions. It'd be incredibly useful to nest it deep down in the async callback hierarchy. Say, to couple it with jQuery animate's call back.\r\n\r\n```\r\nLocker.LockManual(\"thebiglock\", function() {\r\n    DoSomeWork();\r\n    $(\"MyLife\").animate( \"fast\", function() {\r\n        FetchNewAjaxContentAndReplaceMyMainContent();\r\n        Locker.Release(\"thebiglock\");\r\n    });\r\n});\r\n```\r\n\r\nNow this makes it work exactly as you'd except. And you can call the Locker.Release from anywhere, even from an external call or not even at all (of course, in which case your tasks are going to keep getting piled up until you do.)\r\n\r\nAnd last but not the least - Priorities.\r\n\r\n```\r\nLocker.Lock(\"thebiglock\", function() {\r\n    DoSomeWork();\r\n    FetchNewAjaxContentAndReplaceMyMainContent();\r\n}, 20);\r\n```\r\n\r\nThe default priority of jobs is 10.  Higher the value, higher the priority.\r\n\r\n**Priority values example:**\r\n\r\n```\r\nvar test = function(no) {\r\n    var priority = Math.ceil(Math.random() * 10);\r\n    Locker.Lock(\"t1\", function () { \r\n            console.log(\"Task no: \" + no + \", Priority: \" + priority);\r\n    }, priority);\r\n};\r\n\r\n\r\nfor (var i=0; i<10; i++)\r\n{ \r\n    test(i);\r\n} \r\n```\r\n\r\n**Output:**\r\n\r\n```\r\nTask no: 0, Priority: 8\r\nTask no: 1, Priority: 8\r\nTask no: 4, Priority: 7\r\nTask no: 6, Priority: 7\r\nTask no: 9, Priority: 7\r\nTask no: 8, Priority: 5\r\nTask no: 2, Priority: 3\r\nTask no: 5, Priority: 3\r\nTask no: 7, Priority: 1\r\nTask no: 3, Priority: 1\r\n```\r\n\r\nAs you'd expect, the locking mechanism makes it a reliable tasking system. Extend, modify and utilize it at will. Have fun!\r\n\r\nPVL"}